
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Concurrency and parallelism &#8212; Comp350: Software design v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="PIM app" href="pim.html" />
    <link rel="prev" title="Data modelling" href="data.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="concurrency-and-parallelism">
<h1>Concurrency and parallelism<a class="headerlink" href="#concurrency-and-parallelism" title="Permalink to this heading">¶</a></h1>
<p>The internet’s architecture means that machines can (in general) talk to
each other if they know each others’ IP address, which they can often
get if they know the relevant domain names. This means that a “server”
computer running an application as a service can be hit with a request
from any number of “client” computers at any time.</p>
<figure class="align-center" id="id1">
<img alt="Depiction of concurrent messages flowing between systems" src="_images/concurrency.png" />
<figcaption>
<p><span class="caption-number">Fig. 3 </span><span class="caption-text">Each double-ended arrow depicts a stream of messages that can
happen at any time concurrently with each other and the server
and database need to do their job and service these requests
while maintaining expectations of the service.</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>This poses some important questions to ask of our application and
scenarios to test rigorously for production use.</p>
<ol class="arabic simple">
<li><p>What happens when our service handlers are hit “at the same time”
by two different requests?</p></li>
<li><p>If our service handler modifies some piece of data in our database,
then what happens when another request comes in when the earlier
request is in the process of being handled and the database is
still working on the previous statement?</p></li>
<li><p>What happens if our service request handler needs to make a request to
another service to fulfil what was asked of it and that service is doing
some destructive operation while another request comes in?</p></li>
</ol>
<p>You can see how the “simplicity” of what we’ve been doing in our backend code
can cross over quickly into “damn, this is broken” territory in such a
common scenario. Welcome to back-end engineering, which focuses on a
principled way to build and deploy systems that can handle such loads!</p>
<p>A number of system approaches have evolved to deal with these concurrency
issues over time while, for the most part, retaining programming simplicity. In
this chapter, we look at two – coroutining on a single thread, and database
transactions.</p>
<section id="terminology">
<h2>Terminology<a class="headerlink" href="#terminology" title="Permalink to this heading">¶</a></h2>
<dl>
<dt><strong>Concurrency</strong> versus <strong>parallelism</strong></dt><dd><p>For our purposes, “concurrency” refers to activities that can happen on
independent timelines either logically or literally. “Parallelism” refers
to activities that necessarily happen on independent timelines. While
“parallelism” usually refers to multiple processors working independently
(even if they happen to be on the same chip), “concurrency” is used to talk
about organizing computation as coordinated interactions between temporally
independent agents – virtual or real.</p>
</dd>
<dt><strong>Process</strong></dt><dd><p>Refers to an independent unit of computation provided as a resource by the
operating system. So it is considered short for “operating system process”.
Whenever you run a command on the shell, for example, you start such a
“process”, it runs until completion and then exits. Each such process has
its own memory space assigned by the OS, which also manages fair allocation
of compute time for all running processes on a finite number of available
CPU “cores”. If processes need to share information, they need to send it
to each other via explicitly addressed messages using various
“inter-process communication” (IPC) mechanisms such as “pipes”, “sockets”
and “message buses”.</p>
</dd>
<dt><strong>Thread</strong></dt><dd><p>Similar to a “process”, this is provided as a resource by the operating
system again. The main difference is that threads are resources that live
within processes and can share memory. Since threads are started by the
main program of a process, the OS assumes that the program knows how to
manage the sharing of memory and resources between threads through various
coordination mechanisms such as “mutexes”, “semaphores”, “signals” and
“message queues”.</p>
</dd>
<dt><strong>Event</strong></dt><dd><p>A broad term that refers to a representation of something that happened at
a particular time in relation to the system under consideration. For
example, a packet received on the network, a mouse click made by a user, a
timer that expired, are all such events.</p>
</dd>
<dt><strong>Event loop</strong></dt><dd><p>A control loop that dispatches events coming in via a queue to assigned
“handlers” which are functions that will perform some (hopefully brief)
computation and return quickly to the event loop. “Events” are populated
into a FIFO queue as they arrive and the event loop handles them one
by one.</p>
</dd>
<dt><strong>Handler</strong></dt><dd><p>A function (usually a “closure”) that is assigned to be called when a
particular type of event is encountered. A given event may be assigned
multiple handlers, all of which will be called in an undetermined order –
usually in the order of installation of the handlers, but it is better to
not assume that. An example mouse click event handler being attached to
a button in a Javascript driven UI –</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&quot;mybutton&quot;</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;click&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="kd">function</span><span class="w"> </span><span class="p">(</span><span class="nx">event</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">/// do stuff with `event`</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">);</span>
</pre></div>
</div>
<p>An API request handler in python being attached to an API end point using FastAPI –</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>

<span class="nd">@app</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;/todolist/</span><span class="si">{item_id}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">get_todolist_item</span><span class="p">(</span><span class="n">item_id</span> <span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="c1"># Find the item and construct an appropriate</span>
    <span class="c1"># JSON compatible representation of it.</span>
    <span class="k">return</span> <span class="n">item</span>
</pre></div>
</div>
</dd>
</dl>
</section>
<section id="coroutining-on-a-single-thread">
<h2>Coroutining on a single thread<a class="headerlink" href="#coroutining-on-a-single-thread" title="Permalink to this heading">¶</a></h2>
<p>We know that our computers can run multiple processes in parallel – as in two
instructions from two programs can be in the process of execution by the
processor <strong>at the same time</strong> because our processors have multiple “cores”,
with each “core” usually capable of service two “threads”.</p>
<p>In the early days of the internet, every request from a client would be handled
by spawning off an operating system process and these issues of concurrency
were demonic to deal with without proper engineering and testing. These days
though, there is general recognition that much of the hard work is delegated to
other systems and the “server” process spends most of its time idling, waiting
for a request, rather than servicing a request.</p>
<p>To captialize on this observation, systems such as NodeJS and python now have
frameworks which essentially handle requests in a single operating system thread.
When we write our handlers as ordinary functions, this means that when one of
our handler functions is working, any request that comes in is placed into a
queue and will wait for the running handler to finish its job before the
request gets handled. In this way, requests get “serialized”.</p>
<figure class="align-center" id="id2">
<img alt="Depiction of an event loop processing messages from a queue." src="_images/eventloop.png" />
<figcaption>
<p><span class="caption-number">Fig. 4 </span><span class="caption-text">As different types of events come in from various sub-systems, they’re
added to a queue for processing. When the event loop gains control, it
picks an event from the FIFO queue, calls the designed “handler” function,
and then moves on to the next event once it regains control.</span><a class="headerlink" href="#id2" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
<p>That alone is not sufficient and describes only “single threaded operation” and
no “coroutining”. If we now consider the scenario that the handler function
might actually be twiddling its metaphorical thumbs waiting for a reply from
another service from across the world, it would seem unfair to the request
waiting in the queue that the thread is idle and yet it won’t process the
request in the queue. Typically, such “thumb twiddling” happens during I/O
requests, either to subsystems on the same computer such as the file system or
GPU, or another process on the same system, or another process on another
computer.</p>
<p>To address this, Javascript and Python’s “async/await” mechanism puts the
“event loop” (the “thumb twiddler”) in control and turns the handlers into
functions that can “return” multiple times. So a handler that needs to wait for
another request to complete would do the following –</p>
<ol class="arabic simple">
<li><p>Create and send the request to the remote party.</p></li>
<li><p>Ask the event loop to resume the handler once the remote party responds.</p></li>
<li><p>Transfer control back to the event loop.</p></li>
</ol>
<p>Now, the event loop is free to handle the next request in the queue
even though the earlier handler has not finished. To be clear, this
still does not clear our plate of potential problems since the request
the handler sent out could be destructive in some way and if another
request for the same thing comes in (called a “race condition”), we’re
still left with the question of what should actually happen.</p>
<p>The concept of “generators” underlies the “async/await” mechanism by providing
the ability to “return” from a function  multiple times while preserving its
execution state, using a keyword such as <code class="docutils literal notranslate"><span class="pre">yield</span></code>.</p>
<p>In python, coroutines are created using the keywords <code class="docutils literal notranslate"><span class="pre">async</span></code> (short for
asynchronous) and paused for results from another asynchronous operation using
the keyword <code class="docutils literal notranslate"><span class="pre">await</span></code>.</p>
<figure class="align-center" id="id3">
<img alt="Illustrates co-routining between two &quot;async&quot; functions" src="_images/coroutining.png" />
<figcaption>
<p><span class="caption-number">Fig. 5 </span><span class="caption-text">The sequence diagram illustrates how two routines (functions) cooperate via
the event loop to yield time to other operations that need attention while
within the same thread of control. You can see how at any time only one of
the three are active. Such “cooperating routines” are why they’re called
“coroutines”, as opposed to a “routine” which takes up all the resources of
a thread for itself.</span><a class="headerlink" href="#id3" title="Permalink to this image">¶</a></p>
</figcaption>
</figure>
</section>
<section id="database-transactions">
<h2>Database transactions<a class="headerlink" href="#database-transactions" title="Permalink to this heading">¶</a></h2>
<p>If we now think of the database as a “service” and our application as its
“client”, we can see how the database also needs to contend with potentially
conflicting requests. While one request asks the DB to modify some set of rows
in one way, another might come in and ask to modify an overlapping set of rows
in another way. What is a DB to do in such a scenario?</p>
<p>DB creators do what is best in such a circumstance – which is to provide
the programmer with mechanisms using which they can dictate what is to happen.
One such mechanism is the “transaction”.</p>
<p>A “transaction” refers to a carved out <em>sequence</em> of operations, which when
executed as unit, the database will guarantee some properties of the outcome –</p>
<ol class="arabic simple">
<li><p>The DB guarantees that either the transaction completes in its entirety,
or fails entirely and will not leave the database in an intermediate
“half done” state. Think about this a bit and you’ll see that it can take
substantial machinery to ensure this property … called “Atomicity”.</p></li>
<li><p>The DB guarantees that the transaction will complete and leave the database
in a “consistent” state – where all the database constraints (such as inter-table
relationships, index tables, etc.) are all consistent with the contents
of the database. This property is referred to as “consistency”.</p></li>
<li><p>Furthermore, the DB also guarantees that two concurrent transactions where
one is writing to the DB and another is reading from it, won’t see
each others’ intermediate states. Transactions are therefore said to be
“isolated”.</p></li>
<li><p>Once the DB declares a transaction to be complete, it guarantees that any
data stored as a consequence will be retained in storage even if in that instant
the database were to crash or the computer’s power be cut off (or imagine
any other such violent interruptions). This is called “durability”.</p></li>
</ol>
<p>Databases which provide transactions with all four of these properties (which
<a class="reference external" href="https://www.postgresql.org/">PostgreSQL</a> and <a class="reference external" href="https://www.mysql.com/">MySQL</a> do as well as <a class="reference external" href="https://www.sqlite.org/index.html">SQLite3</a>) are said to provide “ACID
transactions” where “ACID” is the common acronym for “Atomic, Consistent,
Isolated and Durable” transactions.</p>
<p>Unless you have a good reason not to, it is always good to execute your SQL
queries within a “transaction”. With sqlite3, this is marked by the “begin”
and “commit”/”rollback” statements. So your python code will look like -</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">do_transaction</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">closing</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">cursor</span><span class="p">())</span> <span class="k">as</span> <span class="n">cur</span><span class="p">:</span>
        <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;begin&quot;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Run your SQL commands that must be run as a unit.</span>
            <span class="c1"># cur.execute(&quot;...&quot;)</span>
            <span class="c1"># cur.execute(&quot;...&quot;)</span>

            <span class="c1"># Finally &quot;commit&quot; your transaction.</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;commit&quot;</span><span class="p">)</span>
        <span class="n">catch</span> <span class="n">db</span><span class="o">.</span><span class="n">Error</span><span class="p">:</span>
            <span class="c1"># In case some failure occurred during the transaction,</span>
            <span class="c1"># we should &quot;rollback&quot; any changes that we happened to do</span>
            <span class="c1"># so that the database stays consistent.</span>
            <span class="n">cur</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;rollback&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>With these, we’re still running our database queries synchronously and therefore
need to address the question of “what happens when it takes a long time to
respond to a query?”. The <a class="reference external" href="https://github.com/omnilib/aiosqlite">aiosqlite</a> package in python turns the DB calls into
async calls and therefore returns frequently enough to the event loop to not block
other requests to our server.</p>
</section>
<section id="communicating-sequential-processes-csp">
<h2>Communicating Sequential Processes (CSP)<a class="headerlink" href="#communicating-sequential-processes-csp" title="Permalink to this heading">¶</a></h2>
<p>CSP offers a way to organize concurrent computation that’s gained significant
adoption of late, in addition to the “async/await” based approaches. In this
model, logically isolated processes cooperate to accomplish a task by sending
messages to each other via channels. Such a process typically waits for a
message on a channel (a message is an arbitrary piece of data in this case) and
uses it to advance its computation until it needs to either send or receive
another message.</p>
<p><a class="reference external" href="https://www.erlang.org/">Erlang</a> and <a class="reference external" href="https://elixir-lang.org/">Elixir</a> (based on Erlang) are languages that provide first
class runtimes that use this model to organize resilient concurrent computation
at scale.</p>
<p><a class="reference external" href="https://go.dev/">Golang</a> also offers the CSP model via “go routines”. <a class="reference external" href="https://clojure.org/index">Clojure</a>’s <a class="reference external" href="https://clojure.org/reference/async">core.async</a> library
also offers the CSP model.</p>
</section>
<section id="promises-and-futures">
<h2>Promises and Futures<a class="headerlink" href="#promises-and-futures" title="Permalink to this heading">¶</a></h2>
<p>The “async/await” mechanisms in Javascript and Python provide the notion of
“Promise” (in Javascript) and “Future”) in python, where both those terms refer
to the same concept.</p>
<p>When an async task that is expected to complete after some time by returning a
value is started, it immediately returns with a placeholder object that’s
called a “Promise” or a “Future” that represents the value that will be
available later, if the task is successful. Such an object provides a point to
which further computations that are to happen after the value becomes available
can be attached. With Javascript, <code class="docutils literal notranslate"><span class="pre">Promise</span></code> objects have a <code class="docutils literal notranslate"><span class="pre">.then</span></code> method
to which you can pass a function that will be called with “fulfilled value of
the promise” once it becomes available. The <code class="docutils literal notranslate"><span class="pre">.then</span></code> itself returns another
<code class="docutils literal notranslate"><span class="pre">Promise</span></code> object which represents the future return value of the last
computation setup, and to which we can attach a further computation, and so on.
In the case of python’s <code class="docutils literal notranslate"><span class="pre">Future</span></code> object, the corresponding method is
<code class="docutils literal notranslate"><span class="pre">add_done_callback</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">async</span></code> and <code class="docutils literal notranslate"><span class="pre">await</span></code> keywords are “syntactic sugar” on top of such
Promises/Futures.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp350: Software design</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="shell.html">The “shell”</a></li>
<li class="toctree-l1"><a class="reference internal" href="regex.html">Basics of “regular expressions”</a></li>
<li class="toctree-l1"><a class="reference internal" href="minilangs.html">Many mini languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="git.html">A student’s guide to git</a></li>
<li class="toctree-l1"><a class="reference internal" href="tips.html">Some utility tips to help you</a></li>
<li class="toctree-l1"><a class="reference internal" href="json.html">JSON</a></li>
<li class="toctree-l1"><a class="reference internal" href="html.html">HTML/XHTML</a></li>
<li class="toctree-l1"><a class="reference internal" href="js.html">A crash course in JS</a></li>
<li class="toctree-l1"><a class="reference internal" href="rest.html">Representational State Transfer (REST)</a></li>
<li class="toctree-l1"><a class="reference internal" href="data.html">Data modelling</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Concurrency and parallelism</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#terminology">Terminology</a></li>
<li class="toctree-l2"><a class="reference internal" href="#coroutining-on-a-single-thread">Coroutining on a single thread</a></li>
<li class="toctree-l2"><a class="reference internal" href="#database-transactions">Database transactions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#communicating-sequential-processes-csp">Communicating Sequential Processes (CSP)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#promises-and-futures">Promises and Futures</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pim.html">PIM app</a></li>
<li class="toctree-l1"><a class="reference internal" href="trust.html">Trust issues</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="data.html" title="previous chapter">Data modelling</a></li>
      <li>Next: <a href="pim.html" title="next chapter">PIM app</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, Srikumar K. S..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/par.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>