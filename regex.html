
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Basics of “regular expressions” &#8212; Comp350: Software design v1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Many mini languages" href="minilangs.html" />
    <link rel="prev" title="The “shell”" href="shell.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="basics-of-regular-expressions">
<h1>Basics of “regular expressions”<a class="headerlink" href="#basics-of-regular-expressions" title="Permalink to this heading">¶</a></h1>
<p>When computing, we often come across situations where we want to describe some
action to be taken on textual data that matches certain patterns. Regular
expressions (abbr. “regex”) are a common pattern description language based on
which efficient pattern processing can be done. They are not fully general, but
are sufficient for many simple data extraction and transformation needs that
every programming language has a regex library included in the standard
package. They all have mostly the same concepts, but sometimes differ in syntax
in small ways due to the context of usage. We’ll concern ourselves with
<code class="docutils literal notranslate"><span class="pre">grep</span></code> here and you can learn the differences on your own once you know this.</p>
<p><code class="docutils literal notranslate"><span class="pre">grep</span></code> (the “GNU regular expression parser”) command is fully described on
the <a class="reference external" href="https://www.gnu.org/software/grep/manual/grep.html">grep man page</a> including all the component constructs of the language,
but I offer a commonly used subset here to give you a flavour of how to use it.</p>
<section id="searching-for-words-and-phrases">
<h2>Searching for words and phrases<a class="headerlink" href="#searching-for-words-and-phrases" title="Permalink to this heading">¶</a></h2>
<p>To search for the exact phrase “King Kong versus Godzilla” in a movie script text
file, you simply do <code class="docutils literal notranslate"><span class="pre">grep</span> <span class="pre">'King</span> <span class="pre">Kong</span> <span class="pre">versus</span> <span class="pre">Godzilla'</span> <span class="pre">FILENAME</span></code>. The first argument
of <code class="docutils literal notranslate"><span class="pre">grep</span></code> is the regular expression or “pattern” to search for. If the <code class="docutils literal notranslate"><span class="pre">FILENAME</span></code>
is omitted, <code class="docutils literal notranslate"><span class="pre">grep</span></code> will search its <em>stdin</em> for the pattern line by line.</p>
<p>A few things to note -</p>
<ol class="arabic simple">
<li><p>That entire pattern <strong>must</strong> occur on a line in its entirety and can’t be split
across multiple lines. Now, it is possible to extend the notion to do multi-line
search, but grep is largely useful for problems where the entire pattern is not
split across lines since its output is line by line.</p></li>
<li><p>The pattern as given is case sensitive, meaning it will not match <code class="docutils literal notranslate"><span class="pre">king</span>
<span class="pre">kong</span> <span class="pre">versus</span> <span class="pre">godzilla</span></code>. To make it ignore the case, use the <code class="docutils literal notranslate"><span class="pre">-i</span></code> flag before
giving the pattern.</p></li>
<li><p>Every character matters - i.e. the given pattern will not match against <code class="docutils literal notranslate"><span class="pre">King</span>
<span class="pre">Kong</span> <span class="pre">versus</span>&#160; <span class="pre">Godzilla</span></code> (note the extra space character between <code class="docutils literal notranslate"><span class="pre">versus</span></code>
and <code class="docutils literal notranslate"><span class="pre">Godzilla</span></code>).</p></li>
</ol>
</section>
<section id="precision-and-recall">
<h2>Precision and Recall<a class="headerlink" href="#precision-and-recall" title="Permalink to this heading">¶</a></h2>
<p>When you’re constructing a search pattern, you may want to have the concepts
of “precision” and “recall” clear in your minds and construct patterns such
that both precision and recall are as close to 1.0 as necessary for your problem
at hand.</p>
<p>Learn about <a class="reference external" href="https://en.wikipedia.org/wiki/Precision_and_recall">precision and recall</a>.</p>
<p>In the context of search patterns, your goal with constructing a pattern
is to select a specific subset of a set of strings (lines, typically).
A number of things may happen when you do this –</p>
<ol class="arabic simple">
<li><p>A string that your pattern selects may be what you’re looking for. This is
called a “true positive” (TP).</p></li>
<li><p>A string that your pattern does not match is a string that you do not want
to select. This is called a “true negative” (TN).</p></li>
<li><p>A string that your pattern selects is something that you actually wanted
to exclude. This is called a “false positive” (FP).</p></li>
<li><p>A string that your pattern does not match is a string that you actually
wanted. This is called a “false negative” (FN).</p></li>
</ol>
<p><strong>Precision</strong> refers to the ratio TP / (TP + FP). When precision is 0.0 or low,
it means your pattern is matching against too many strings that you don’t want.
In this case, your pattern is too broad and you need to make your pattern more
“precise”. When precision is closer to 1.0, it means whatever strings match
your pattern are almost always ones you’re looking for, though they may not be
all of the strings you’re looking for.</p>
<p><strong>Recall</strong> refers to the ratio TP / (TP + FN). When recall is low, it means
that your pattern is missing out on matching many of the strings that are of
interest to you. When recall is close to 1.0, it means it is managing to
catch nearly all of the strings of interest to you, even if it means it lets
through some that are not of interest to you.</p>
<p>An ideal pattern is one for which both precision and recall are at 1.0. It may
not always be necessary to ensure this because it may be too complicated to do
so for very little payoff. So you may in some circumstances strike a compromise
based on what you already know about the specific set of strings you are
matching against. For example, you may know that the set of strings only have
lower case characters and so you don’t need to make your pattern robust to
character case variations.</p>
<p>Sometimes, you may be able to split your task into stages where in one stage
you use an approximate pattern to filter some strings and then apply a second
pattern to further trim the errors in the first approximate match.</p>
<div class="admonition-be-aware-of-precision-and-recall admonition">
<p class="admonition-title">Be aware of <em>Precision</em> and <em>Recall</em></p>
<p>However you construct your pattern, make sure you’ve thought through the
four possibilities listed about and ensure that the “false negative” and
“false positive” cases are eliminated in your problem context.</p>
</div>
</section>
<section id="wildcard">
<h2>Wildcard<a class="headerlink" href="#wildcard" title="Permalink to this heading">¶</a></h2>
<p>The “<code class="docutils literal notranslate"><span class="pre">.</span></code>” (period) character in a pattern will match against any character
including white space. So the pattern <code class="docutils literal notranslate"><span class="pre">King</span> <span class="pre">Kong.versus.Godzilla</span></code> will match
against <code class="docutils literal notranslate"><span class="pre">King</span> <span class="pre">Kong-versus-Godzilla</span></code> also, <code class="docutils literal notranslate"><span class="pre">King</span> <span class="pre">KongSversusOGodzilla</span></code> as
well.</p>
<p>So you might already see that your regular expression may match more than the
intended set of patterns (termed higher “recall”) or match fewer than the
intended set (termed higher “precision”). Often, if you manage high recall, you
may have sacrificed precision and vice versa. You’ll have to test against a known
set to ensure you’re hitting the right spot for your problem at hand.</p>
<p>So how do you match against a literal period character “<code class="docutils literal notranslate"><span class="pre">.</span></code>” in the text you’re
searching? For that, you “escape” the special meaning of “<code class="docutils literal notranslate"><span class="pre">.</span></code>” in the pattern by
prefixing it with “<code class="docutils literal notranslate"><span class="pre">\</span></code>”. So <code class="docutils literal notranslate"><span class="pre">King</span> <span class="pre">Kong\.versus\.Godzilla</span></code> will only match the
text “King Kong.versus.Godzilla” in the file. The “<code class="docutils literal notranslate"><span class="pre">\</span></code>” character can be used to
escape the special meaning of any of the other characters we discuss here too.
It also <strong>imparts</strong> special meaning to some otherwise ordinary characters as
well. For example “<code class="docutils literal notranslate"><span class="pre">\s</span></code>” stands for any white space character including the tab
character.</p>
</section>
<section id="character-sets">
<h2>Character sets<a class="headerlink" href="#character-sets" title="Permalink to this heading">¶</a></h2>
<p>Supposing I wish to match “King Kong” as well as “Ping pong”. Can I describe
both using a single regex pattern? Yes. You do it by first noticing the common
parts – i.e. “_ing _ong” and then look at what are the options for the “blank”
portions. The first blank may be occupied by either “K” or “P” and the second
blank may be occupied by either “K” or “p” (lower case). This notion of “set of
allowed characters” is specified using square brackets like this – “<code class="docutils literal notranslate"><span class="pre">[KP]ing</span>
<span class="pre">[Kp]ong</span></code>”.</p>
<p>The characters listed within “<code class="docutils literal notranslate"><span class="pre">[]</span></code>” form a “character set” and will match a
single character that occurs in the specified set. You can, for example, match
“any decimal digit” using “<code class="docutils literal notranslate"><span class="pre">[0123456789]</span></code>”. It can get tedious to put that
long expression whenever you need to idea of “any decimal digit”, so that can
also be abbreviated as “<code class="docutils literal notranslate"><span class="pre">[0-9]</span></code>”, which means exactly the same thing. You can
similarly specify character ranges as well – like “<code class="docutils literal notranslate"><span class="pre">[A-Za-z]</span></code>” which will
match any capitalized or lower case alphabetical character. If you want your
character set to include the “<code class="docutils literal notranslate"><span class="pre">-</span></code>” character, you’ll have to place it at the
start like this “<code class="docutils literal notranslate"><span class="pre">[-0-9\s]</span></code>” (which matches “any decimal digit or hyphen or
any white space character”).</p>
<p><strong>Negation</strong>: To express the idea of “any character that is not in this set”,
you place the “^” character at the start of the character set – i.e.
“<code class="docutils literal notranslate"><span class="pre">[^0-9]</span></code>” will match any character <strong>other than</strong> a decimal digit.</p>
</section>
<section id="alternatives">
<h2>Alternatives<a class="headerlink" href="#alternatives" title="Permalink to this heading">¶</a></h2>
<p>If you want to match “either the word ‘Dolphin’ or the word ‘Orca’”, you can express
that idea using the “or” operator – “<code class="docutils literal notranslate"><span class="pre">\|</span></code>”. Note that special meaning is being
imparted to “<code class="docutils literal notranslate"><span class="pre">|</span></code>” by the prefix “<code class="docutils literal notranslate"><span class="pre">\</span></code>”.</p>
<p>For example, we could’ve also solved the problem in the previous section using
the (longer) pattern – “<code class="docutils literal notranslate"><span class="pre">King</span> <span class="pre">Kong\|Ping</span> <span class="pre">pong</span></code>” – which is to be read as
“‘King Kong’ or ‘Ping pong’”.</p>
</section>
<section id="repeated-matches">
<h2>Repeated matches<a class="headerlink" href="#repeated-matches" title="Permalink to this heading">¶</a></h2>
<p>We’re often interested in searching for patterns such as “a decimal number” which
may have more than one decimal digit and we don’t know in advance how many to expect.
There are some constructs that help describe such patterns.</p>
<p>You’ve seen character patterns so far. Suffixing a character pattern with
“<code class="docutils literal notranslate"><span class="pre">{m,n}</span></code>” will cause the pattern to match <code class="docutils literal notranslate"><span class="pre">m</span></code> to <code class="docutils literal notranslate"><span class="pre">n</span></code> consecutive
occurrences of the pattern. So if you want to describe the portion of a number
that occurs after the decimal digit and restrict is to a minimum of 1 and a
maximum of 3 digits, you can specify that as “<code class="docutils literal notranslate"><span class="pre">\.[0-9]{1,3}</span></code>”. (Note how we
“escaped” the special meaning of “.” to turn it into a literal period.)</p>
<p>If you want to express the idea of “at least m occurrences”, just omit the “n”
part (but keep the comma) – i.e. like “<code class="docutils literal notranslate"><span class="pre">{m,}</span></code>”. Similarly to express the
idea of “at most n occurrences”, omit the “m” part (but keep the comma) – i.e.
like “<code class="docutils literal notranslate"><span class="pre">{,n}</span></code>”. The latter case also includes “zero occurrences”. To match
an exact number of times, you can either give “<code class="docutils literal notranslate"><span class="pre">{m,m}</span></code>” or abbreviate it as
“<code class="docutils literal notranslate"><span class="pre">{m}</span></code>”.</p>
<p>“<code class="docutils literal notranslate"><span class="pre">{1,}</span></code>” describes “one or more occurrences” and since this is a commonly used
pattern it has a special character for it “<code class="docutils literal notranslate"><span class="pre">\+</span></code>”. <a class="footnote-reference brackets" href="#esc" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p>Similarly, the notion of “zero or more occurrences” is also commonly used and has a special
character for it “<code class="docutils literal notranslate"><span class="pre">\*</span></code>”. <a class="footnote-reference brackets" href="#esc" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p>These are considered “eager matching operators”, meaning they will match as many
characters as possible. So if you have a text “xxxxx” and you’re using “<code class="docutils literal notranslate"><span class="pre">x\+</span></code>” to
match it, though the notion of “one or more xs” includes the idea of “3 xs”, it will
match the whole run of them <strong>eagerly</strong>.</p>
<aside class="footnote brackets" id="esc" role="note">
<span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span>
<span class="backrefs">(<a role="doc-backlink" href="#id2">1</a>,<a role="doc-backlink" href="#id3">2</a>)</span>
<p>In other situations, the “+” and “*” is usually not escaped like
that. In the context of <code class="docutils literal notranslate"><span class="pre">grep</span></code> though, “+” by itself means the literal
character and so “+” is needed to impart the special meaning of “one or
more” to the preceding item.</p>
</aside>
</section>
<section id="grouping">
<h2>Grouping<a class="headerlink" href="#grouping" title="Permalink to this heading">¶</a></h2>
<p>You may have come across <a class="reference external" href="https://en.wikipedia.org/wiki/Universally_unique_identifier">UUIDs</a> which are identifiers usually written out
like - <code class="docutils literal notranslate"><span class="pre">4a1df6b0-f626-40d2-95ad-f7f2f8f8d1fd</span></code>. Can we, and if so how do we,
describe such UUIDs using a regular expression?</p>
<p>First we notice that each “part” separated by the hyphen character consists of
one or more “hexadecimal” characters. This idea we may describe using the
regex pattern “<code class="docutils literal notranslate"><span class="pre">[0-9a-f]\+</span></code>”.</p>
<div class="admonition-pause-and-think admonition">
<p class="admonition-title"><strong>Pause and think</strong></p>
<p>Is the pattern “<code class="docutils literal notranslate"><span class="pre">[0-9a-f]\+</span></code>” precise or a more loose match than we need?</p>
</div>
<p>So we may conceive of the UUID pattern as “hexdigits followed by one or more
occurrences of (hyphen followed by hexdigits)”, where we’ve placed the group
like “-f626” in parentheses to indicate it needs to be considered as a “unit”.</p>
<p><code class="docutils literal notranslate"><span class="pre">grep</span></code> lets you specify such groupings using “<code class="docutils literal notranslate"><span class="pre">\(</span></code>“/”<code class="docutils literal notranslate"><span class="pre">\)</span></code>” matched pairs.
The “&quot; escape character is needed because “(” and “)” will match literally
those characters.</p>
<p>Using that we can express the “(hyphen followed by hexdigits)” part as –
“<code class="docutils literal notranslate"><span class="pre">\(-[0-9a-f]\+\)</span></code>”. To now apply the “one or more of” to that entire group,
we simply place “<code class="docutils literal notranslate"><span class="pre">\+</span></code>” after the group like this - “<code class="docutils literal notranslate"><span class="pre">\(-[0-9a-f]\+\)\+</span></code>”.
So you see that “<code class="docutils literal notranslate"><span class="pre">\+</span></code>” applies to the “unit” that immediately precedes it,
be it a single character, or a parenthesized group.</p>
<div class="admonition-pause-and-think admonition">
<p class="admonition-title"><strong>Pause and think</strong></p>
<p>How would you then say “exactly 4 occurrences of the group (hyphen followed
by hexdigits)”.</p>
</div>
<p>Now we can complete a possible description of a UUID using the regex –
“<code class="docutils literal notranslate"><span class="pre">[0-9a-f]\+\(-[0-9a-f]\+\)\+</span></code>”.</p>
<div class="admonition-pause-and-think admonition">
<p class="admonition-title"><strong>Pause and think</strong></p>
<p>That final regex pattern will also match “2-3-4-5-6-7-8-9” which is not a
valid UUID. The parts of the UUID are fixed and must have exactly the same
fixed number of characters. So can you modify the regex to match UUIDs
strictly (i.e. with greater precision)?</p>
</div>
</section>
<section id="invisible-characters">
<h2>Invisible characters<a class="headerlink" href="#invisible-characters" title="Permalink to this heading">¶</a></h2>
<p>The special character “^” matches the “start of the line”. This isn’t visible
as a character in the text, but represents the cursor position at the start of
the line <strong>before</strong> the first character on the line.</p>
<p>Similarly, the character “$” matches the “end of the line” and represents the cursor
position <strong>after</strong> the last character on the line.</p>
<p>So if you want to match against all lines that are only hyphens, you can use
a pattern like – “<code class="docutils literal notranslate"><span class="pre">^-\+$</span></code>”.</p>
</section>
<section id="there-s-more">
<h2>There’s more<a class="headerlink" href="#there-s-more" title="Permalink to this heading">¶</a></h2>
<p>Regex libraries offer a lot more than what I’ve described here, including
special support for character classes, unicode characters, back references,
look-ahead and look-behind, other invisible character positions such as “word
boundary” and more. However, the above collection should serve you well for
many common needs.</p>
<div class="admonition-important admonition">
<p class="admonition-title"><strong>Important</strong></p>
<p>While the language is richer than described here, do not underestimate the
value of <strong>composing</strong> the above features. For example, you can provides
options (”<code class="docutils literal notranslate"><span class="pre">\|</span></code>”) within groups (”<code class="docutils literal notranslate"><span class="pre">\(\)</span></code>”) and ask for at least 2
occurrences (”<code class="docutils literal notranslate"><span class="pre">{2,}</span></code>”), and so on.</p>
</div>
<p>To learn about the other features, you can refer to the <a class="reference external" href="https://www.gnu.org/software/grep/manual/grep.html">grep man page</a>
pointed to earlier.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Comp350: Software design</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="shell.html">The “shell”</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Basics of “regular expressions”</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#searching-for-words-and-phrases">Searching for words and phrases</a></li>
<li class="toctree-l2"><a class="reference internal" href="#precision-and-recall">Precision and Recall</a></li>
<li class="toctree-l2"><a class="reference internal" href="#wildcard">Wildcard</a></li>
<li class="toctree-l2"><a class="reference internal" href="#character-sets">Character sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#alternatives">Alternatives</a></li>
<li class="toctree-l2"><a class="reference internal" href="#repeated-matches">Repeated matches</a></li>
<li class="toctree-l2"><a class="reference internal" href="#grouping">Grouping</a></li>
<li class="toctree-l2"><a class="reference internal" href="#invisible-characters">Invisible characters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#there-s-more">There’s more</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="minilangs.html">Many mini languages</a></li>
<li class="toctree-l1"><a class="reference internal" href="git.html">A student’s guide to git</a></li>
<li class="toctree-l1"><a class="reference internal" href="tips.html">Some utility tips to help you</a></li>
<li class="toctree-l1"><a class="reference internal" href="json.html">JSON</a></li>
<li class="toctree-l1"><a class="reference internal" href="html.html">HTML/XHTML</a></li>
<li class="toctree-l1"><a class="reference internal" href="js.html">A crash course in JS</a></li>
<li class="toctree-l1"><a class="reference internal" href="rest.html">Representational State Transfer (REST)</a></li>
<li class="toctree-l1"><a class="reference internal" href="data.html">Data modelling</a></li>
<li class="toctree-l1"><a class="reference internal" href="par.html">Concurrency and parallelism</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="shell.html" title="previous chapter">The “shell”</a></li>
      <li>Next: <a href="minilangs.html" title="next chapter">Many mini languages</a></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, Srikumar K. S..
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 5.0.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/regex.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>